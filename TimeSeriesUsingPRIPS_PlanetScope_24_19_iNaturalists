var plots = ee.FeatureCollection('projects/usask-468318/assets/Presence_Absence_Sites');

// Filter for Crested Wheatgrass (CW)
var PresencePlots = plots.filter(ee.Filter.eq('Type', 'Presence'));
print('CW Plots', PresencePlots.size());
// Filter for Native Grass (NG)
var AbsencePlots = plots.filter(ee.Filter.eq('Type', 'Absence'));
print('NG Plots', AbsencePlots.size());

// Combine both plot types
var allPlots = PresencePlots.merge(AbsencePlots);
// Filter for Crested Wheatgrass (CW)
var cwPlots = plots.filter(ee.Filter.eq('Species', 'CW'));
print('CW Plots', cwPlots);
// Filter for Native Grass (NG)
var ngPlots = plots.filter(ee.Filter.eq('Species', 'NG'));
print('NG Plots', ngPlots);


//Cloud masking
function maskCloudsAndShadows(analyticImage, udmImage) {
  // Read cloud (band 6) and shadow (band 3) from UDM2
  var cloudMask = udmImage.select('b6').eq(0);  // 0 = no cloud
  var shadowMask = udmImage.select('b3').eq(0); // 0 = no shadow
  
  // Combine masks (keep pixels that are both cloud-free AND shadow-free)
  var clearMask = cloudMask.and(shadowMask);
  
  return analyticImage.updateMask(clearMask);
}

// Apply masking to each image pair
var MAR18_masked = maskCloudsAndShadows(MAR18, udmMAR18);
var MAR27_masked = maskCloudsAndShadows(MAR27, udmMAR27);
// var APR01_masked = maskCloudsAndShadows(APR01, udmAPR01);
var APR09_masked = maskCloudsAndShadows(APR09, udmAPR09);
var APR14_masked = maskCloudsAndShadows(APR14, udmAPR14);
var APR20_masked = maskCloudsAndShadows(APR20, udmAPR20);
var APR23_masked = maskCloudsAndShadows(APR23, udmAPR23);
var APR26_masked = maskCloudsAndShadows(APR26, udmAPR26);
var MAY09_masked = maskCloudsAndShadows(MAY09, udmMAY09);
var MAY10_masked = maskCloudsAndShadows(MAY10, udmMAY10);
var MAY12_masked = maskCloudsAndShadows(MAY12, udmMAY12);
var MAY13_masked = maskCloudsAndShadows(MAY13, udmMAY13);
var MAY19_masked = maskCloudsAndShadows(MAY19, udmMAY19);
var MAY27_masked = maskCloudsAndShadows(MAY27, udmMAY27);
var JUNE11_masked = maskCloudsAndShadows(JUNE11, udmJUNE11);
var JUNE18_masked = maskCloudsAndShadows(JUNE18, udmJUNE18);
var JUNE22_masked = maskCloudsAndShadows(JUNE22, udmJUNE22);
var JUNE23_masked = maskCloudsAndShadows(JUNE23, udmJUNE23);
var JUNE30_masked = maskCloudsAndShadows(JUNE30, udmJUNE30);
var JULY08_masked = maskCloudsAndShadows(JULY08, udmJULY08);
var JULY09_masked = maskCloudsAndShadows(JULY09, udmJULY09);
var JULY10_masked = maskCloudsAndShadows(JULY10, udmJULY10);
var JULY24_masked = maskCloudsAndShadows(JULY24, udmJULY24);
var JULY27_masked = maskCloudsAndShadows(JULY27, udmJULY27);
var JULY31_masked = maskCloudsAndShadows(JULY31, udmJULY31);
var AUG01_masked = maskCloudsAndShadows(AUG01, udmAUG01);
var AUG10_masked = maskCloudsAndShadows(AUG10, udmAUG10);
var AUG14_masked = maskCloudsAndShadows(AUG14, udmAUG14);
var AUG18_masked = maskCloudsAndShadows(AUG18, udmAUG18);
var AUG22_masked = maskCloudsAndShadows(AUG22, udmAUG22);
var AUG31_masked = maskCloudsAndShadows(AUG31, udmAUG31);
var SEP06_masked = maskCloudsAndShadows(SEP06, udmSEP06);
var SEP07_masked = maskCloudsAndShadows(SEP07, udmSEP07);
var SEP14_masked = maskCloudsAndShadows(SEP14, udmSEP14);
var SEP24_masked = maskCloudsAndShadows(SEP24, udmSEP24);
var SEP28_masked = maskCloudsAndShadows(SEP28, udmSEP28);
var OCT08_masked = maskCloudsAndShadows(OCT08, udmOCT08);
var OCT12_masked = maskCloudsAndShadows(OCT12, udmOCT12);

// Create ImageCollection with masked images
var PS = ee.ImageCollection.fromImages([
  MAR18_masked.set('system:time_start', ee.Date('2024-03-18').millis()),
  MAR27_masked.set('system:time_start', ee.Date('2024-03-27').millis()),
  // APR01_masked.set('system:time_start', ee.Date('2024-04-01').millis()),
  APR09_masked.set('system:time_start', ee.Date('2024-04-09').millis()),
  APR14_masked.set('system:time_start', ee.Date('2024-04-14').millis()),
  APR20_masked.set('system:time_start', ee.Date('2024-04-20').millis()),
  APR23_masked.set('system:time_start', ee.Date('2024-04-23').millis()),
  APR26_masked.set('system:time_start', ee.Date('2024-04-26').millis()),
  MAY09_masked.set('system:time_start', ee.Date('2024-05-09').millis()),
  MAY10_masked.set('system:time_start', ee.Date('2024-05-10').millis()),
  MAY12_masked.set('system:time_start', ee.Date('2024-05-12').millis()),
  MAY13_masked.set('system:time_start', ee.Date('2024-05-13').millis()),
  MAY19_masked.set('system:time_start', ee.Date('2024-05-19').millis()),
  MAY27_masked.set('system:time_start', ee.Date('2024-05-27').millis()),
  JUNE11_masked.set('system:time_start', ee.Date('2024-06-11').millis()),
  JUNE18_masked.set('system:time_start', ee.Date('2024-06-18').millis()),
  JUNE22_masked.set('system:time_start', ee.Date('2024-06-22').millis()),
  JUNE23_masked.set('system:time_start', ee.Date('2024-06-23').millis()),
  JUNE30_masked.set('system:time_start', ee.Date('2024-06-30').millis()),
  JULY08_masked.set('system:time_start', ee.Date('2024-07-08').millis()),
  JULY09_masked.set('system:time_start', ee.Date('2024-07-09').millis()),
  JULY10_masked.set('system:time_start', ee.Date('2024-07-10').millis()),
  JULY24_masked.set('system:time_start', ee.Date('2024-07-24').millis()),
  JULY27_masked.set('system:time_start', ee.Date('2024-07-27').millis()),
  JULY31_masked.set('system:time_start', ee.Date('2024-07-31').millis()),
  AUG01_masked.set('system:time_start', ee.Date('2024-08-01').millis()),
  AUG10_masked.set('system:time_start', ee.Date('2024-08-10').millis()),
  AUG14_masked.set('system:time_start', ee.Date('2024-08-14').millis()),
  AUG18_masked.set('system:time_start', ee.Date('2024-08-18').millis()),
  AUG22_masked.set('system:time_start', ee.Date('2024-08-22').millis()),
  AUG31_masked.set('system:time_start', ee.Date('2024-08-31').millis()),
  SEP06_masked.set('system:time_start', ee.Date('2024-09-06').millis()),
  SEP07_masked.set('system:time_start', ee.Date('2024-09-07').millis()),
  SEP14_masked.set('system:time_start', ee.Date('2024-09-14').millis()),
  SEP24_masked.set('system:time_start', ee.Date('2024-09-24').millis()),
  SEP28_masked.set('system:time_start', ee.Date('2024-09-28').millis()),
  OCT08_masked.set('system:time_start', ee.Date('2024-10-08').millis()),
  OCT12_masked.set('system:time_start', ee.Date('2024-10-12').millis())
]);

// // Create ImageCollection with proper dates
// var PS = ee.ImageCollection.fromImages([
//   OCT08.set('system:time_start', ee.Date('2024-10-08').millis()),
//   OCT12.set('system:time_start', ee.Date('2024-10-12').millis()),
//   MAR18.set('system:time_start', ee.Date('2024-03-18').millis()),
//   MAR27.set('system:time_start', ee.Date('2024-03-27').millis()),
//   APR09.set('system:time_start', ee.Date('2024-04-09').millis()),
//   APR23.set('system:time_start', ee.Date('2024-04-23').millis()),
//   MAY10.set('system:time_start', ee.Date('2024-05-10').millis()),
//   MAY13.set('system:time_start', ee.Date('2024-05-13').millis()),
//   JUNE11.set('system:time_start', ee.Date('2024-06-11').millis()),
//   JULY24.set('system:time_start', ee.Date('2024-07-24').millis()),
//   AUG10.set('system:time_start', ee.Date('2024-08-10').millis()),
//   AUG31.set('system:time_start', ee.Date('2024-08-31').millis()),
//   SEP06.set('system:time_start', ee.Date('2024-09-06').millis()),
//   SEP07.set('system:time_start', ee.Date('2024-09-07').millis()),
//   SEP14.set('system:time_start', ee.Date('2024-09-14').millis()),
//   SEP24.set('system:time_start', ee.Date('2024-09-24').millis()),
//   SEP28.set('system:time_start', ee.Date('2024-09-28').millis()),
//   APR14.set('system:time_start', ee.Date('2024-04-14').millis()),
//   APR20.set('system:time_start', ee.Date('2024-04-20').millis()),
//   APR26.set('system:time_start', ee.Date('2024-04-26').millis()),
//   MAY09.set('system:time_start', ee.Date('2024-05-09').millis()),
//   MAY12.set('system:time_start', ee.Date('2024-05-12').millis()),
//   MAY19.set('system:time_start', ee.Date('2024-05-19').millis()),
//   MAY27.set('system:time_start', ee.Date('2024-05-27').millis()),
//   JUNE18.set('system:time_start', ee.Date('2024-06-18').millis()),
//   JUNE22.set('system:time_start', ee.Date('2024-06-22').millis()),
//   JUNE23.set('system:time_start', ee.Date('2024-06-23').millis()),
//   JUNE30.set('system:time_start', ee.Date('2024-06-30').millis()),
//   JULY08.set('system:time_start', ee.Date('2024-07-08').millis()),
//   JULY09.set('system:time_start', ee.Date('2024-07-09').millis()),
//   JULY10.set('system:time_start', ee.Date('2024-07-10').millis()),
//   JULY27.set('system:time_start', ee.Date('2024-07-27').millis()),
//   JULY31.set('system:time_start', ee.Date('2024-07-31').millis()),
//   AUG01.set('system:time_start', ee.Date('2024-08-01').millis()),
//   AUG14.set('system:time_start', ee.Date('2024-08-14').millis()),
//   AUG18.set('system:time_start', ee.Date('2024-08-18').millis()),
//   AUG22.set('system:time_start', ee.Date('2024-08-22').millis())
// ]);

print('Image Collection:', PS);

// Function to add an NDVI band to an image
function addNDVI(image) {
  var ndvi = image
    .normalizedDifference(['b3', 'b4'])  
    .rename('ndvi');
  return image.addBands(ndvi);
}

var originalCollection = PS.map(addNDVI);
print(originalCollection);

// Display a time-series chart
var chart = ui.Chart.image.series({
  imageCollection: originalCollection.select('ndvi'),
  region: cwPlots,
  reducer: ee.Reducer.mean(),
  scale: 20
}).setOptions({
      title: 'Original PRI Time Series',
      interpolateNulls: false,
      vAxis: {title: 'PRI', viewWindow: {min: 0, max: 2}},
      hAxis: {title: '', format: 'YYYY-MM'},
      lineWidth: 1,
      pointSize: 4,
      series: {
        0: {color: '#238b45'},
      },
});

print(chart);


// Generate an empty multi-band image matching the bands
// in the original collection
var bandNames = ee.Image(originalCollection.first()).bandNames();
var numBands = bandNames.size();
var initBands = ee.List.repeat(ee.Image(), numBands);
var initImage = ee.ImageCollection(initBands).toBands().rename(bandNames)

//****************************************************************************************************************//
//*****************************************5 day NDVI time series*************************************************//
//****************************************************************************************************************//
 
// // Select the interval. We will have 1 image every n days
// var n = 5;
// var firstImage = ee.Image(originalCollection.sort('system:time_start').first())
// var lastImage = ee.Image(originalCollection.sort('system:time_start', false).first())
// var timeStart = ee.Date(firstImage.get('system:time_start'))
// var timeEnd = ee.Date(lastImage.get('system:time_start'))

// var totalDays = timeEnd.difference(timeStart, 'day');
// var daysToInterpolate = ee.List.sequence(0, totalDays, n)

// var initImages = daysToInterpolate.map(function(day) {
//   var image = initImage.set({
//     'system:index': ee.Number(day).format('%d'),
//     'system:time_start': timeStart.advance(day, 'day').millis(),
//     // Set a property so we can identify interpolated images
//     'type': 'interpolated'
//   })
//   return image
// })


// var initCol = ee.ImageCollection.fromImages(initImages)
// print('Empty Collection', initCol.size())

// // Merge original and empty collections
// var originalCollection = originalCollection.merge(initCol)

// // Interpolation

// // Add a band containing timestamp to each image
// // This will be used to do pixel-wise interpolation later
// var originalCollection = originalCollection.map(function(image) {
//   var timeImage = image.metadata('system:time_start').rename('timestamp')
//   // The time image doesn't have a mask. 
//   // We set the mask of the time band to be the same as the first band of the image
//   var timeImageMasked = timeImage.updateMask(image.mask().select(0))
//   return image.addBands(timeImageMasked).toFloat();
// })

// // For each image in the collection, we need to find all images
// // before and after the specified time-window

// // This is accomplished using Joins
// // We need to do 2 joins
// // Join 1: Join the collection with itself to find all images before each image
// // Join 2: Join the collection with itself to find all images after each image

// // We first define the filters needed for the join

// // Define a maxDifference filter to find all images within the specified days
// // The filter needs the time difference in milliseconds
// // Convert days to milliseconds

// // Specify the time-window to look for unmasked pixel
// var days = 30;
// var millis = ee.Number(days).multiply(1000*60*60*24)

// var maxDiffFilter = ee.Filter.maxDifference({
//   difference: millis,
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // We need a lessThanOrEquals filter to find all images after a given image
// // This will compare the given image's timestamp against other images' timestamps
// var lessEqFilter = ee.Filter.lessThanOrEquals({
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // We need a greaterThanOrEquals filter to find all images before a given image
// // This will compare the given image's timestamp against other images' timestamps
// var greaterEqFilter = ee.Filter.greaterThanOrEquals({
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // Apply the joins

// // For the first join, we need to match all images that are after the given image.
// // To do this we need to match 2 conditions
// // 1. The resulting images must be within the specified time-window of target image
// // 2. The target image's timestamp must be lesser than the timestamp of resulting images
// // Combine two filters to match both these conditions
// var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// // This join will find all images after, sorted in descending order
// // This will gives us images so that closest is last
// var join1 = ee.Join.saveAll({
//   matchesKey: 'after',
//   ordering: 'system:time_start',
//   ascending: false})
  
// var join1Result = join1.apply({
//   primary: originalCollection,
//   secondary: originalCollection,
//   condition: filter1
// })
// // Each image now as a property called 'after' containing
// // all images that come after it within the time-window
// print(join1Result.first())

// // Do the second join now to match all images within the time-window
// // that come before each image
// var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// // This join will find all images before, sorted in ascending order
// // This will gives us images so that closest is last
// var join2 = ee.Join.saveAll({
//   matchesKey: 'before',
//   ordering: 'system:time_start',
//   ascending: true})
  
// var join2Result = join2.apply({
//   primary: join1Result,
//   secondary: join1Result,
//   condition: filter2
// })

// // Each image now as a property called 'before' containing
// // all images that come after it within the time-window
// print(join2Result.first())

// var joinedCol = join2Result;

// // Do the interpolation

// // We now write a function that will be used to interpolate all images
// // This function takes an image and replaces the masked pixels
// // with the interpolated value from before and after images.

// var interpolateImages = function(image) {
//   var image = ee.Image(image);
//   // We get the list of before and after images from the image property
//   // Mosaic the images so we a before and after image with the closest unmasked pixel
//   var beforeImages = ee.List(image.get('before'))
//   var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
//   var afterImages = ee.List(image.get('after'))
//   var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

//   // Interpolation formula
//   // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
//   // y = interpolated image
//   // y1 = before image
//   // y2 = after image
//   // t = interpolation timestamp
//   // t1 = before image timestamp
//   // t2 = after image timestamp
  
//   // We first compute the ratio (t – t1) / (t2 – t1)

//   // Get image with before and after times
//   var t1 = beforeMosaic.select('timestamp').rename('t1')
//   var t2 = afterMosaic.select('timestamp').rename('t2')

//   var t = image.metadata('system:time_start').rename('t')

//   var timeImage = ee.Image.cat([t1, t2, t])

//   var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
//     't': timeImage.select('t'),
//     't1': timeImage.select('t1'),
//     't2': timeImage.select('t2'),
//   })
//   // You can replace timeRatio with a constant value 0.5
//   // if you wanted a simple average
  
//   // Compute an image with the interpolated image y
//   var interpolated = beforeMosaic
//     .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
//   // Replace the masked pixels in the current image with the average value
//   var result = image.unmask(interpolated)
//   return result.copyProperties(image, ['system:time_start'])
// }

// // map() the function to interpolate all images in the collection
// var interpolatedCol = ee.ImageCollection(joinedCol.map(interpolateImages))

// // Once the interpolation are done, remove original images
// // We keep only the generated interpolated images
// var regularCol = interpolatedCol.filter(ee.Filter.eq('type', 'interpolated'))

// print(regularCol,"regularCol")

// // Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: regularCol.select('ndvi'),
//   region: cwPlots,
//   reducer: ee.Reducer.mean(),
//   scale: 20
// }).setOptions({
//       title: 'Regular PRI Time Series',
//       interpolateNulls: false,
//       vAxis: {title: 'PRI', viewWindow: {min: 0, max: 2}},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#238b45'},
//       },
//     })
// print(chart);

// // SavatskyGolayFilter
// // https://www.open-geocomputing.org/OpenEarthEngineLibrary/#.ImageCollection.SavatskyGolayFilter

// // Use the default distanceFunction
// var distanceFunction = function(infromedImage, estimationImage) {
//   return ee.Image.constant(
//       ee.Number(infromedImage.get('system:time_start'))
//       .subtract(
//         ee.Number(estimationImage.get('system:time_start')))
//         );
//   }

// // Apply smoothing

// var oeel=require('users/OEEL/lib:loadAll');

// var order = 3;

// var sgFilteredCol = oeel.ImageCollection.SavatskyGolayFilter(
//   regularCol, 
//   maxDiffFilter,
//   distanceFunction,
//   order)

// print(sgFilteredCol.first(), "michu")
// // print(sgFilteredCol,"sgFilteredCol")
// print(sgFilteredCol.size())

// // Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']),
//   region: cwPlots,
//   reducer: ee.Reducer.mean(),
//   scale: 20
// }).setOptions({
//       lineWidth: 1,
//       title: 'PRI Time Series for Crested Wheatgrass',
//       interpolateNulls: false,
//       vAxis: {title: 'PRI', viewWindow: {min: 0, max: 2}},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#66c2a4', lineDashStyle: [1, 1], pointSize: 2}, // Original NDVI
//         1: {color: '#238b45', lineWidth: 2 }, // Smoothed NDVI
//       },

//     })
// print(chart);

// // Select and rename the bands you want to export
// var exportCollection = sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']);

// // Function to extract values for each image
// var extractValues = function(image) {
//   // Get the image date
//   var date = ee.Date(image.get('system:time_start'));
  
//   // Sample the image at each point in cwPlots
//   var samples = image.sampleRegions({
//     collection: allPlots,
//     scale: 20, // Use the same scale as your chart
//     projection: 'EPSG:4326',
//     geometries: true // Keep the geometry information
//   });
  
//   // Add date and time information to each sample
//   var samplesWithDate = samples.map(function(sample) {
//     return sample.set({
//       'system:time_start': image.get('system:time_start'),
//       'date': date.format('YYYY-MM-dd'),
//       'year': date.get('year'),
//       'month': date.get('month'),
//       'day': date.get('day'),
//       'doy': date.getRelative('day', 'year').add(1) // Day of year
//     });
//   });
  
//   return samplesWithDate;
// };

// // Map the function over all images and flatten the results
// var allSamples = exportCollection.map(extractValues).flatten();

// // Export the data to Google Drive
// Export.table.toDrive({
//   collection: allSamples,
//   description: 'PRI_5Days_2ndMethods',
//   folder: 'GEE_Exports', // Change this to your preferred folder name
//   fileNamePrefix: 'ndvi_timeseries_cw',
//   fileFormat: 'CSV',
//   selectors: [
//     'system:time_start',  // Original timestamp
//     'date',              // Formatted date (YYYY-MM-dd)
//     'doy',               // Day of year
//     'Site',              // Site name from cwPlots
//     'ndvi',              // Original NDVI values
//     'ndvi_sg',
//     'Type'// Savitzky-Golay filtered NDVI values
//   ]
// });


// // Method 2: Build the multi-band image manually with proper naming
// var imageList = sgFilteredCol.select('d_0_ndvi').toList(sgFilteredCol.size());

// var bandNames = ee.List.sequence(0, sgFilteredCol.size().subtract(1))
//   .map(function(i) {
//     return ee.String('t').cat(ee.Number(i).format('%02d')); // Creates: t00, t01, t02, etc.
//   });

// var sgFilteredBands = ee.ImageCollection.fromImages(imageList).toBands().rename(bandNames);

// // Debug: Check what bands exist in sgFilteredCol
// print('Available bands in sgFilteredCol:', sgFilteredBands);

// Export.image.toAsset({
//   image: sgFilteredBands,
//   description: 'SG_Filtered_NDVI_Collection_SLPP_CreatedWithallthe2019_2020_iNaturalist_PS',
//   assetId: 'projects/usask-468318/assets/sg_filtered_ndvi_timeseries_2024',
//   region: SLPP.geometry().bounds(),
//   scale: 3,
//   maxPixels: 1e13
// });


// // Create a separate FeatureCollection with band-to-date mapping
// var bandDateMapping = ee.FeatureCollection(
//   ee.List.sequence(0, sgFilteredCol.size().subtract(1)).map(function(i) {
//     var image = ee.Image(sgFilteredCol.toList(1, i).get(0));
//     var bandName = ee.String('t').cat(ee.Number(i).format('%02d'));
    
//     // Convert timestamp to readable date
//     var timestamp = image.get('system:time_start');
//     var date = ee.Date(timestamp);
//     var dateString = date.format('YYYY-MM-dd');
//     var dayOfYear = date.getRelative('day', 'year').add(1);
    
//     return ee.Feature(null, {
//       'band_name': bandName,
//       'band_index': i,
//       'timestamp': timestamp,
//       'date': dateString,
//       'day_of_year': dayOfYear,
//       'year': date.get('year'),
//       'month': date.get('month'),
//       'day': date.get('day')
//     });
//   })
// );

// // Export to Google Drive as CSV
// Export.table.toDrive({
//   collection: bandDateMapping,
//   description: 'PRI_5_Day_Band_Date_Mapping_Drive_PS',
//   folder: 'GEE_Exports',
//   fileNamePrefix: 'PRI_5_Day_Band_Date_Mapping_Drive_PS',
//   fileFormat: 'CSV'
// });

// // Show specific properties from first mapping
// var firstMapping = bandDateMapping.first();
// print('First band name:', firstMapping.get('band_name'));
// print('First date:', firstMapping.get('date'));
// print('First day of year:', firstMapping.get('day_of_year'));

//****************************************************************************************************************//
//*****************************************5 day NDVI time series end*********************************************//
//****************************************************************************************************************//
// //****************************************************************************************************************//
// //*****************************************10 day NDVI time series************************************************//
// //****************************************************************************************************************//

// //Select the interval. We will have 1 image every n days
// var n = 10;
// var firstImage = ee.Image(originalCollection.sort('system:time_start').first())
// var lastImage = ee.Image(originalCollection.sort('system:time_start', false).first())
// var timeStart = ee.Date(firstImage.get('system:time_start'))
// var timeEnd = ee.Date(lastImage.get('system:time_start'))

// var totalDays = timeEnd.difference(timeStart, 'day');
// var daysToInterpolate = ee.List.sequence(0, totalDays, n)

// var initImages = daysToInterpolate.map(function(day) {
//   var image = initImage.set({
//     'system:index': ee.Number(day).format('%d'),
//     'system:time_start': timeStart.advance(day, 'day').millis(),
//     // Set a property so we can identify interpolated images
//     'type': 'interpolated'
//   })
//   return image
// })


// var initCol = ee.ImageCollection.fromImages(initImages)
// print('Empty Collection', initCol.size())

// // Merge original and empty collections
// var originalCollection = originalCollection.merge(initCol)

// // Interpolation

// // Add a band containing timestamp to each image
// // This will be used to do pixel-wise interpolation later
// var originalCollection = originalCollection.map(function(image) {
//   var timeImage = image.metadata('system:time_start').rename('timestamp')
//   // The time image doesn't have a mask. 
//   // We set the mask of the time band to be the same as the first band of the image
//   var timeImageMasked = timeImage.updateMask(image.mask().select(0))
//   return image.addBands(timeImageMasked).toFloat();
// })

// // For each image in the collection, we need to find all images
// // before and after the specified time-window

// // This is accomplished using Joins
// // We need to do 2 joins
// // Join 1: Join the collection with itself to find all images before each image
// // Join 2: Join the collection with itself to find all images after each image

// // We first define the filters needed for the join

// // Define a maxDifference filter to find all images within the specified days
// // The filter needs the time difference in milliseconds
// // Convert days to milliseconds

// // Specify the time-window to look for unmasked pixel
// var days = 30;
// var millis = ee.Number(days).multiply(1000*60*60*24)

// var maxDiffFilter = ee.Filter.maxDifference({
//   difference: millis,
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // We need a lessThanOrEquals filter to find all images after a given image
// // This will compare the given image's timestamp against other images' timestamps
// var lessEqFilter = ee.Filter.lessThanOrEquals({
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // We need a greaterThanOrEquals filter to find all images before a given image
// // This will compare the given image's timestamp against other images' timestamps
// var greaterEqFilter = ee.Filter.greaterThanOrEquals({
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // Apply the joins

// // For the first join, we need to match all images that are after the given image.
// // To do this we need to match 2 conditions
// // 1. The resulting images must be within the specified time-window of target image
// // 2. The target image's timestamp must be lesser than the timestamp of resulting images
// // Combine two filters to match both these conditions
// var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// // This join will find all images after, sorted in descending order
// // This will gives us images so that closest is last
// var join1 = ee.Join.saveAll({
//   matchesKey: 'after',
//   ordering: 'system:time_start',
//   ascending: false})
  
// var join1Result = join1.apply({
//   primary: originalCollection,
//   secondary: originalCollection,
//   condition: filter1
// })
// // Each image now as a property called 'after' containing
// // all images that come after it within the time-window
// print(join1Result.first())

// // Do the second join now to match all images within the time-window
// // that come before each image
// var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// // This join will find all images before, sorted in ascending order
// // This will gives us images so that closest is last
// var join2 = ee.Join.saveAll({
//   matchesKey: 'before',
//   ordering: 'system:time_start',
//   ascending: true})
  
// var join2Result = join2.apply({
//   primary: join1Result,
//   secondary: join1Result,
//   condition: filter2
// })

// // Each image now as a property called 'before' containing
// // all images that come after it within the time-window
// print(join2Result.first())

// var joinedCol = join2Result;

// // Do the interpolation

// // We now write a function that will be used to interpolate all images
// // This function takes an image and replaces the masked pixels
// // with the interpolated value from before and after images.

// var interpolateImages = function(image) {
//   var image = ee.Image(image);
//   // We get the list of before and after images from the image property
//   // Mosaic the images so we a before and after image with the closest unmasked pixel
//   var beforeImages = ee.List(image.get('before'))
//   var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
//   var afterImages = ee.List(image.get('after'))
//   var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

//   // Interpolation formula
//   // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
//   // y = interpolated image
//   // y1 = before image
//   // y2 = after image
//   // t = interpolation timestamp
//   // t1 = before image timestamp
//   // t2 = after image timestamp
  
//   // We first compute the ratio (t – t1) / (t2 – t1)

//   // Get image with before and after times
//   var t1 = beforeMosaic.select('timestamp').rename('t1')
//   var t2 = afterMosaic.select('timestamp').rename('t2')

//   var t = image.metadata('system:time_start').rename('t')

//   var timeImage = ee.Image.cat([t1, t2, t])

//   var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
//     't': timeImage.select('t'),
//     't1': timeImage.select('t1'),
//     't2': timeImage.select('t2'),
//   })
//   // You can replace timeRatio with a constant value 0.5
//   // if you wanted a simple average
  
//   // Compute an image with the interpolated image y
//   var interpolated = beforeMosaic
//     .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
//   // Replace the masked pixels in the current image with the average value
//   var result = image.unmask(interpolated)
//   return result.copyProperties(image, ['system:time_start'])
// }

// // map() the function to interpolate all images in the collection
// var interpolatedCol = ee.ImageCollection(joinedCol.map(interpolateImages))

// // Once the interpolation are done, remove original images
// // We keep only the generated interpolated images
// var regularCol = interpolatedCol.filter(ee.Filter.eq('type', 'interpolated'))

// print(regularCol,"regularCol")

// // Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: regularCol.select('ndvi'),
//   region: cwPlots,
//   reducer: ee.Reducer.mean(),
//   scale: 20
// }).setOptions({
//       title: 'Regular PRIS2 Time Series',
//       interpolateNulls: false,
//       vAxis: {title: 'PRIS2', viewWindow: {min: 0, max: 2}},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#238b45'},
//       },
//     })
// print(chart);

// // SavatskyGolayFilter
// // https://www.open-geocomputing.org/OpenEarthEngineLibrary/#.ImageCollection.SavatskyGolayFilter

// // Use the default distanceFunction
// var distanceFunction = function(infromedImage, estimationImage) {
//   return ee.Image.constant(
//       ee.Number(infromedImage.get('system:time_start'))
//       .subtract(
//         ee.Number(estimationImage.get('system:time_start')))
//         );
//   }

// // Apply smoothing

// var oeel=require('users/OEEL/lib:loadAll');

// var order = 3;

// var sgFilteredCol = oeel.ImageCollection.SavatskyGolayFilter(
//   regularCol, 
//   maxDiffFilter,
//   distanceFunction,
//   order)

// print(sgFilteredCol.first(), "michu")
// // print(sgFilteredCol,"sgFilteredCol")
// print(sgFilteredCol.size())

// // Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']),
//   region: cwPlots,
//   reducer: ee.Reducer.mean(),
//   scale: 20
// }).setOptions({
//       lineWidth: 1,
//       title: 'PRIS2 Time Series for Crested Wheatgrass',
//       interpolateNulls: false,
//       vAxis: {title: 'PRIS2', viewWindow: {min: 0, max: 2}},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#66c2a4', lineDashStyle: [1, 1], pointSize: 2}, // Original NDVI
//         1: {color: '#238b45', lineWidth: 2 }, // Smoothed NDVI
//       },

//     })
// print(chart);

// // Select and rename the bands you want to export
// var exportCollection = sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']);

// // Function to extract values for each image
// var extractValues = function(image) {
//   // Get the image date
//   var date = ee.Date(image.get('system:time_start'));
  
//   // Sample the image at each point in cwPlots
//   var samples = image.sampleRegions({
//     collection: allPlots,
//     scale: 20, // Use the same scale as your chart
//     projection: 'EPSG:4326',
//     geometries: true // Keep the geometry information
//   });
  
//   // Add date and time information to each sample
//   var samplesWithDate = samples.map(function(sample) {
//     return sample.set({
//       'system:time_start': image.get('system:time_start'),
//       'date': date.format('YYYY-MM-dd'),
//       'year': date.get('year'),
//       'month': date.get('month'),
//       'day': date.get('day'),
//       'doy': date.getRelative('day', 'year').add(1) // Day of year
//     });
//   });
  
//   return samplesWithDate;
// };

// // Map the function over all images and flatten the results
// var allSamples = exportCollection.map(extractValues).flatten();

// // Export the data to Google Drive
// Export.table.toDrive({
//   collection: allSamples,
//   description: 'PRI_10Days_2ndMethods',
//   folder: 'GEE_Exports', // Change this to your preferred folder name
//   fileNamePrefix: 'ndvi_timeseries_cw',
//   fileFormat: 'CSV',
//   selectors: [
//     'system:time_start',  // Original timestamp
//     'date',              // Formatted date (YYYY-MM-dd)
//     'doy',               // Day of year
//     'Site',              // Site name from cwPlots
//     'ndvi',              // Original NDVI values
//     'ndvi_sg',
//     'Type'// Savitzky-Golay filtered NDVI values
//   ]
// });


// // Method 2: Build the multi-band image manually with proper naming
// var imageList = sgFilteredCol.select('d_0_ndvi').toList(sgFilteredCol.size());

// var bandNames = ee.List.sequence(0, sgFilteredCol.size().subtract(1))
//   .map(function(i) {
//     return ee.String('t').cat(ee.Number(i).format('%02d')); // Creates: t00, t01, t02, etc.
//   });

// var sgFilteredBands = ee.ImageCollection.fromImages(imageList).toBands().rename(bandNames);

// // Debug: Check what bands exist in sgFilteredCol
// print('Available bands in sgFilteredCol:', sgFilteredBands);

// Export.image.toAsset({
//   image: sgFilteredBands,
//   description: 'SG_Filtered_NDVI_Collection_SLPP_CreatedWithallthe2019_2020_iNaturalist_PS',
//   assetId: 'projects/usask-468318/assets/sg_filtered_ndvi_timeseries_2024_PS',
//   region: SLPP.geometry().bounds(),
//   scale: 3,
//   maxPixels: 1e13
// });


// // Create a separate FeatureCollection with band-to-date mapping
// var bandDateMapping = ee.FeatureCollection(
//   ee.List.sequence(0, sgFilteredCol.size().subtract(1)).map(function(i) {
//     var image = ee.Image(sgFilteredCol.toList(1, i).get(0));
//     var bandName = ee.String('t').cat(ee.Number(i).format('%02d'));
    
//     // Convert timestamp to readable date
//     var timestamp = image.get('system:time_start');
//     var date = ee.Date(timestamp);
//     var dateString = date.format('YYYY-MM-dd');
//     var dayOfYear = date.getRelative('day', 'year').add(1);
    
//     return ee.Feature(null, {
//       'band_name': bandName,
//       'band_index': i,
//       'timestamp': timestamp,
//       'date': dateString,
//       'day_of_year': dayOfYear,
//       'year': date.get('year'),
//       'month': date.get('month'),
//       'day': date.get('day')
//     });
//   })
// );

// // Export to Google Drive as CSV
// Export.table.toDrive({
//   collection: bandDateMapping,
//   description: 'PRI_10_Day_Band_Date_Mapping_Drive_PS',
//   folder: 'GEE_Exports',
//   fileNamePrefix: 'PRI_10_Day_Band_Date_Mapping_Drive',
//   fileFormat: 'CSV'
// });


// //****************************************************************************************************************//
// //*****************************************10 day NDVI time series end*********************************************//
// //****************************************************************************************************************//
//****************************************************************************************************************//
//*****************************************30 day NDVI time series************************************************//
//****************************************************************************************************************//

// //Select the interval. We will have 1 image every n days
// var n = 30;
// var firstImage = ee.Image(originalCollection.sort('system:time_start').first())
// var lastImage = ee.Image(originalCollection.sort('system:time_start', false).first())
// var timeStart = ee.Date(firstImage.get('system:time_start'))
// var timeEnd = ee.Date(lastImage.get('system:time_start'))

// var totalDays = timeEnd.difference(timeStart, 'day');
// var daysToInterpolate = ee.List.sequence(0, totalDays, n)

// var initImages = daysToInterpolate.map(function(day) {
//   var image = initImage.set({
//     'system:index': ee.Number(day).format('%d'),
//     'system:time_start': timeStart.advance(day, 'day').millis(),
//     // Set a property so we can identify interpolated images
//     'type': 'interpolated'
//   })
//   return image
// })


// var initCol = ee.ImageCollection.fromImages(initImages)
// print('Empty Collection', initCol.size())

// // Merge original and empty collections
// var originalCollection = originalCollection.merge(initCol)

// // Interpolation

// // Add a band containing timestamp to each image
// // This will be used to do pixel-wise interpolation later
// var originalCollection = originalCollection.map(function(image) {
//   var timeImage = image.metadata('system:time_start').rename('timestamp')
//   // The time image doesn't have a mask. 
//   // We set the mask of the time band to be the same as the first band of the image
//   var timeImageMasked = timeImage.updateMask(image.mask().select(0))
//   return image.addBands(timeImageMasked).toFloat();
// })

// // For each image in the collection, we need to find all images
// // before and after the specified time-window

// // This is accomplished using Joins
// // We need to do 2 joins
// // Join 1: Join the collection with itself to find all images before each image
// // Join 2: Join the collection with itself to find all images after each image

// // We first define the filters needed for the join

// // Define a maxDifference filter to find all images within the specified days
// // The filter needs the time difference in milliseconds
// // Convert days to milliseconds

// // Specify the time-window to look for unmasked pixel
// var days = 120;
// var millis = ee.Number(days).multiply(1000*60*60*24)

// var maxDiffFilter = ee.Filter.maxDifference({
//   difference: millis,
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // We need a lessThanOrEquals filter to find all images after a given image
// // This will compare the given image's timestamp against other images' timestamps
// var lessEqFilter = ee.Filter.lessThanOrEquals({
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // We need a greaterThanOrEquals filter to find all images before a given image
// // This will compare the given image's timestamp against other images' timestamps
// var greaterEqFilter = ee.Filter.greaterThanOrEquals({
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // Apply the joins

// // For the first join, we need to match all images that are after the given image.
// // To do this we need to match 2 conditions
// // 1. The resulting images must be within the specified time-window of target image
// // 2. The target image's timestamp must be lesser than the timestamp of resulting images
// // Combine two filters to match both these conditions
// var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// // This join will find all images after, sorted in descending order
// // This will gives us images so that closest is last
// var join1 = ee.Join.saveAll({
//   matchesKey: 'after',
//   ordering: 'system:time_start',
//   ascending: false})
  
// var join1Result = join1.apply({
//   primary: originalCollection,
//   secondary: originalCollection,
//   condition: filter1
// })
// // Each image now as a property called 'after' containing
// // all images that come after it within the time-window
// print(join1Result.first())

// // Do the second join now to match all images within the time-window
// // that come before each image
// var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// // This join will find all images before, sorted in ascending order
// // This will gives us images so that closest is last
// var join2 = ee.Join.saveAll({
//   matchesKey: 'before',
//   ordering: 'system:time_start',
//   ascending: true})
  
// var join2Result = join2.apply({
//   primary: join1Result,
//   secondary: join1Result,
//   condition: filter2
// })

// // Each image now as a property called 'before' containing
// // all images that come after it within the time-window
// print(join2Result.first())

// var joinedCol = join2Result;

// // Do the interpolation

// // We now write a function that will be used to interpolate all images
// // This function takes an image and replaces the masked pixels
// // with the interpolated value from before and after images.

// var interpolateImages = function(image) {
//   var image = ee.Image(image);
//   // We get the list of before and after images from the image property
//   // Mosaic the images so we a before and after image with the closest unmasked pixel
//   var beforeImages = ee.List(image.get('before'))
//   var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
//   var afterImages = ee.List(image.get('after'))
//   var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

//   // Interpolation formula
//   // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
//   // y = interpolated image
//   // y1 = before image
//   // y2 = after image
//   // t = interpolation timestamp
//   // t1 = before image timestamp
//   // t2 = after image timestamp
  
//   // We first compute the ratio (t – t1) / (t2 – t1)

//   // Get image with before and after times
//   var t1 = beforeMosaic.select('timestamp').rename('t1')
//   var t2 = afterMosaic.select('timestamp').rename('t2')

//   var t = image.metadata('system:time_start').rename('t')

//   var timeImage = ee.Image.cat([t1, t2, t])

//   var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
//     't': timeImage.select('t'),
//     't1': timeImage.select('t1'),
//     't2': timeImage.select('t2'),
//   })
//   // You can replace timeRatio with a constant value 0.5
//   // if you wanted a simple average
  
//   // Compute an image with the interpolated image y
//   var interpolated = beforeMosaic
//     .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
//   // Replace the masked pixels in the current image with the average value
//   var result = image.unmask(interpolated)
//   return result.copyProperties(image, ['system:time_start'])
// }

// // map() the function to interpolate all images in the collection
// var interpolatedCol = ee.ImageCollection(joinedCol.map(interpolateImages))

// // Once the interpolation are done, remove original images
// // We keep only the generated interpolated images
// var regularCol = interpolatedCol.filter(ee.Filter.eq('type', 'interpolated'))

// print(regularCol,"regularCol")

// // Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: regularCol.select('ndvi'),
//   region: cwPlots,
//   reducer: ee.Reducer.mean(),
//   scale: 20
// }).setOptions({
//       title: 'Regular PRI Time Series',
//       interpolateNulls: false,
//       vAxis: {title: 'PRI', viewWindow: {min: 0, max: 2}},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#238b45'},
//       },
//     })
// print(chart);

// // SavatskyGolayFilter
// // https://www.open-geocomputing.org/OpenEarthEngineLibrary/#.ImageCollection.SavatskyGolayFilter

// // Use the default distanceFunction
// var distanceFunction = function(infromedImage, estimationImage) {
//   return ee.Image.constant(
//       ee.Number(infromedImage.get('system:time_start'))
//       .subtract(
//         ee.Number(estimationImage.get('system:time_start')))
//         );
//   }

// // Apply smoothing

// var oeel=require('users/OEEL/lib:loadAll');

// var order = 3;

// var sgFilteredCol = oeel.ImageCollection.SavatskyGolayFilter(
//   regularCol, 
//   maxDiffFilter,
//   distanceFunction,
//   order)

// print(sgFilteredCol.first(), "michu")
// // print(sgFilteredCol,"sgFilteredCol")
// print(sgFilteredCol.size())

// // Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']),
//   region: cwPlots,
//   reducer: ee.Reducer.mean(),
//   scale: 20
// }).setOptions({
//       lineWidth: 1,
//       title: 'PRIS2 Time Series for Crested Wheatgrass',
//       interpolateNulls: false,
//       vAxis: {title: 'PRIS2', viewWindow: {min: 0, max: 2}},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#66c2a4', lineDashStyle: [1, 1], pointSize: 2}, // Original NDVI
//         1: {color: '#238b45', lineWidth: 2 }, // Smoothed NDVI
//       },

//     })
// print(chart);

// // Select and rename the bands you want to export
// var exportCollection = sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']);

// // Function to extract values for each image
// var extractValues = function(image) {
//   // Get the image date
//   var date = ee.Date(image.get('system:time_start'));
  
//   // Sample the image at each point in cwPlots
//   var samples = image.sampleRegions({
//     collection: allPlots,
//     scale: 20, // Use the same scale as your chart
//     projection: 'EPSG:4326',
//     geometries: true // Keep the geometry information
//   });
  
//   // Add date and time information to each sample
//   var samplesWithDate = samples.map(function(sample) {
//     return sample.set({
//       'system:time_start': image.get('system:time_start'),
//       'date': date.format('YYYY-MM-dd'),
//       'year': date.get('year'),
//       'month': date.get('month'),
//       'day': date.get('day'),
//       'doy': date.getRelative('day', 'year').add(1) // Day of year
//     });
//   });
  
//   return samplesWithDate;
// };

// // Map the function over all images and flatten the results
// var allSamples = exportCollection.map(extractValues).flatten();

// // Export the data to Google Drive
// Export.table.toDrive({
//   collection: allSamples,
//   description: 'PRI_30Days_2ndMethods',
//   folder: 'GEE_Exports', // Change this to your preferred folder name
//   fileNamePrefix: 'ndvi_timeseries_cw',
//   fileFormat: 'CSV',
//   selectors: [
//     'system:time_start',  // Original timestamp
//     'date',              // Formatted date (YYYY-MM-dd)
//     'doy',               // Day of year
//     'Site',              // Site name from cwPlots
//     'ndvi',              // Original NDVI values
//     'ndvi_sg',
//     'Type'// Savitzky-Golay filtered NDVI values
//   ]
// });


// // Method 2: Build the multi-band image manually with proper naming
// var imageList = sgFilteredCol.select('d_0_ndvi').toList(sgFilteredCol.size());

// var bandNames = ee.List.sequence(0, sgFilteredCol.size().subtract(1))
//   .map(function(i) {
//     return ee.String('t').cat(ee.Number(i).format('%02d')); // Creates: t00, t01, t02, etc.
//   });

// var sgFilteredBands = ee.ImageCollection.fromImages(imageList).toBands().rename(bandNames);

// // Debug: Check what bands exist in sgFilteredCol
// print('Available bands in sgFilteredCol:', sgFilteredBands);

// Export.image.toAsset({
//   image: sgFilteredBands,
//   description: 'SG_Filtered_NDVI_Collection_SLPP_CreatedWithallthe2019_2020_iNaturalist_PS',
//   assetId: 'projects/usask-468318/assets/sg_filtered_ndvi_timeseries_2024',
//   region: SLPP.geometry().bounds(),
//   scale: 3,
//   maxPixels: 1e13
// });


// // Create a separate FeatureCollection with band-to-date mapping
// var bandDateMapping = ee.FeatureCollection(
//   ee.List.sequence(0, sgFilteredCol.size().subtract(1)).map(function(i) {
//     var image = ee.Image(sgFilteredCol.toList(1, i).get(0));
//     var bandName = ee.String('t').cat(ee.Number(i).format('%02d'));
    
//     // Convert timestamp to readable date
//     var timestamp = image.get('system:time_start');
//     var date = ee.Date(timestamp);
//     var dateString = date.format('YYYY-MM-dd');
//     var dayOfYear = date.getRelative('day', 'year').add(1);
    
//     return ee.Feature(null, {
//       'band_name': bandName,
//       'band_index': i,
//       'timestamp': timestamp,
//       'date': dateString,
//       'day_of_year': dayOfYear,
//       'year': date.get('year'),
//       'month': date.get('month'),
//       'day': date.get('day')
//     });
//   })
// );

// // Export to Google Drive as CSV
// Export.table.toDrive({
//   collection: bandDateMapping,
//   description: 'PRI_30_Day_Band_Date_Mapping_Drive_PS',
//   folder: 'GEE_Exports',
//   fileNamePrefix: 'PRI_30_Day_Band_Date_Mapping_Drive_PS',
//   fileFormat: 'CSV'
// });
//****************************************************************************************************************//
//*****************************************30 day NDVI time series end*********************************************//
//****************************************************************************************************************//







