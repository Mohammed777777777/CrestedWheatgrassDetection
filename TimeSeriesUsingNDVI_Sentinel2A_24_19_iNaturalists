var plots = ee.FeatureCollection('projects/usask-468318/assets/Presence_Absence_Sites');

// Filter for Crested Wheatgrass (CW)
var PresencePlots = plots.filter(ee.Filter.eq('Type', 'Presence'));
print('CW Plots', PresencePlots.size());
// Filter for Native Grass (NG)
var AbsencePlots = plots.filter(ee.Filter.eq('Type', 'Absence'));
print('NG Plots', AbsencePlots.size());

// Combine both plot types
var allPlots = PresencePlots.merge(AbsencePlots);

// Filter for Crested Wheatgrass (CW)
var cwPlots = plots.filter(ee.Filter.eq('Species', 'CW'));
print('CW Plots', cwPlots);
// Filter for Native Grass (NG)
var ngPlots = plots.filter(ee.Filter.eq('Species', 'NG'));
print('NG Plots', ngPlots);

var s2 = ee.ImageCollection('COPERNICUS/S2_HARMONIZED');

var startDate = ee.Date.fromYMD(2024, 1, 1);
var endDate = ee.Date.fromYMD(2024, 12, 31);

// Function to add a NDVI band to an image
function addNDVI(image) {
  var ndvi = image.normalizedDifference(['B8', 'B4']).rename('ndvi');
  return image.addBands(ndvi);
} 

// Function to mask clouds
function maskS2clouds(image) {
  var qa = image.select('QA60')
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0).and(
             qa.bitwiseAnd(cirrusBitMask).eq(0))
  return image.updateMask(mask).divide(10000)
      .select("B.*")
      .copyProperties(image, ["system:time_start"])
}

var originalCollection = s2
  .filter(ee.Filter.date(startDate, endDate))
  .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 30))
  .filter(ee.Filter.bounds(cwPlots))
  .map(maskS2clouds)
  .map(addNDVI);
  
// Display a time-series chart
var chart = ui.Chart.image.series({
  imageCollection: originalCollection.select('ndvi'),
  region: cwPlots,
  reducer: ee.Reducer.mean(),
  scale: 20
}).setOptions({
      title: 'Original NDVI Time Series',
      interpolateNulls: false,
      vAxis: {title: 'NDVI', viewWindow: {min: 0, max: 1}},
      hAxis: {title: '', format: 'YYYY-MM'},
      lineWidth: 1,
      pointSize: 4,
      series: {
        0: {color: '#238b45'},
      },

    })  
    
    // Generate an empty multi-band image matching the bands
// in the original collection
var bandNames = ee.Image(originalCollection.first()).bandNames();
var numBands = bandNames.size();
var initBands = ee.List.repeat(ee.Image(), numBands);
var initImage = ee.ImageCollection(initBands).toBands().rename(bandNames)
  

// NOTE: We are doing 5 day and 10 day spectral index time series here. So, in order produce any of them (5 day or 10 day)  
// please do uncomment them first and run the code//
//****************************************************************************************************************//
//*****************************************5 day NDVI time series*************************************************//
//****************************************************************************************************************//
 
// Select the interval. We will have 1 image every n days
var n = 5;
var firstImage = ee.Image(originalCollection.sort('system:time_start').first())
var lastImage = ee.Image(originalCollection.sort('system:time_start', false).first())
var timeStart = ee.Date(firstImage.get('system:time_start'))
var timeEnd = ee.Date(lastImage.get('system:time_start'))

var totalDays = timeEnd.difference(timeStart, 'day');
var daysToInterpolate = ee.List.sequence(0, totalDays, n)

var initImages = daysToInterpolate.map(function(day) {
  var image = initImage.set({
    'system:index': ee.Number(day).format('%d'),
    'system:time_start': timeStart.advance(day, 'day').millis(),
    // Set a property so we can identify interpolated images
    'type': 'interpolated'
  })
  return image
})


var initCol = ee.ImageCollection.fromImages(initImages)
print('Empty Collection', initCol.size())

// Merge original and empty collections
var originalCollection = originalCollection.merge(initCol)

// Interpolation

// Add a band containing timestamp to each image
// This will be used to do pixel-wise interpolation later
var originalCollection = originalCollection.map(function(image) {
  var timeImage = image.metadata('system:time_start').rename('timestamp')
  // The time image doesn't have a mask. 
  // We set the mask of the time band to be the same as the first band of the image
  var timeImageMasked = timeImage.updateMask(image.mask().select(0))
  return image.addBands(timeImageMasked).toFloat();
})

// For each image in the collection, we need to find all images
// before and after the specified time-window

// This is accomplished using Joins
// We need to do 2 joins
// Join 1: Join the collection with itself to find all images before each image
// Join 2: Join the collection with itself to find all images after each image

// We first define the filters needed for the join

// Define a maxDifference filter to find all images within the specified days
// The filter needs the time difference in milliseconds
// Convert days to milliseconds

// Specify the time-window to look for unmasked pixel
var days = 30;
var millis = ee.Number(days).multiply(1000*60*60*24)

var maxDiffFilter = ee.Filter.maxDifference({
  difference: millis,
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a lessThanOrEquals filter to find all images after a given image
// This will compare the given image's timestamp against other images' timestamps
var lessEqFilter = ee.Filter.lessThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// We need a greaterThanOrEquals filter to find all images before a given image
// This will compare the given image's timestamp against other images' timestamps
var greaterEqFilter = ee.Filter.greaterThanOrEquals({
  leftField: 'system:time_start',
  rightField: 'system:time_start'
})

// Apply the joins

// For the first join, we need to match all images that are after the given image.
// To do this we need to match 2 conditions
// 1. The resulting images must be within the specified time-window of target image
// 2. The target image's timestamp must be lesser than the timestamp of resulting images
// Combine two filters to match both these conditions
var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// This join will find all images after, sorted in descending order
// This will gives us images so that closest is last
var join1 = ee.Join.saveAll({
  matchesKey: 'after',
  ordering: 'system:time_start',
  ascending: false})
  
var join1Result = join1.apply({
  primary: originalCollection,
  secondary: originalCollection,
  condition: filter1
})
// Each image now as a property called 'after' containing
// all images that come after it within the time-window
print(join1Result.first())

// Do the second join now to match all images within the time-window
// that come before each image
var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// This join will find all images before, sorted in ascending order
// This will gives us images so that closest is last
var join2 = ee.Join.saveAll({
  matchesKey: 'before',
  ordering: 'system:time_start',
  ascending: true})
  
var join2Result = join2.apply({
  primary: join1Result,
  secondary: join1Result,
  condition: filter2
})

// Each image now as a property called 'before' containing
// all images that come after it within the time-window
print(join2Result.first())

var joinedCol = join2Result;

// Do the interpolation

// We now write a function that will be used to interpolate all images
// This function takes an image and replaces the masked pixels
// with the interpolated value from before and after images.

var interpolateImages = function(image) {
  var image = ee.Image(image);
  // We get the list of before and after images from the image property
  // Mosaic the images so we a before and after image with the closest unmasked pixel
  var beforeImages = ee.List(image.get('before'))
  var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
  var afterImages = ee.List(image.get('after'))
  var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

  // Interpolation formula
  // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
  // y = interpolated image
  // y1 = before image
  // y2 = after image
  // t = interpolation timestamp
  // t1 = before image timestamp
  // t2 = after image timestamp
  
  // We first compute the ratio (t – t1) / (t2 – t1)

  // Get image with before and after times
  var t1 = beforeMosaic.select('timestamp').rename('t1')
  var t2 = afterMosaic.select('timestamp').rename('t2')

  var t = image.metadata('system:time_start').rename('t')

  var timeImage = ee.Image.cat([t1, t2, t])

  var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
    't': timeImage.select('t'),
    't1': timeImage.select('t1'),
    't2': timeImage.select('t2'),
  })
  // You can replace timeRatio with a constant value 0.5
  // if you wanted a simple average
  
  // Compute an image with the interpolated image y
  var interpolated = beforeMosaic
    .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
  // Replace the masked pixels in the current image with the average value
  var result = image.unmask(interpolated)
  return result.copyProperties(image, ['system:time_start'])
}

// map() the function to interpolate all images in the collection
var interpolatedCol = ee.ImageCollection(joinedCol.map(interpolateImages))

// Once the interpolation are done, remove original images
// We keep only the generated interpolated images
var regularCol = interpolatedCol.filter(ee.Filter.eq('type', 'interpolated'))

print(regularCol,"regularCol")

// Display a time-series chart
var chart = ui.Chart.image.series({
  imageCollection: regularCol.select('ndvi'),
  region: cwPlots,
  reducer: ee.Reducer.mean(),
  scale: 20
}).setOptions({
      title: 'Regular NDVI Time Series',
      interpolateNulls: false,
      vAxis: {title: 'NDVI', viewWindow: {min: 0, max: 1}},
      hAxis: {title: '', format: 'YYYY-MM'},
      lineWidth: 1,
      pointSize: 4,
      series: {
        0: {color: '#238b45'},
      },
    })
print(chart);

// SavatskyGolayFilter
// https://www.open-geocomputing.org/OpenEarthEngineLibrary/#.ImageCollection.SavatskyGolayFilter

// Use the default distanceFunction
var distanceFunction = function(infromedImage, estimationImage) {
  return ee.Image.constant(
      ee.Number(infromedImage.get('system:time_start'))
      .subtract(
        ee.Number(estimationImage.get('system:time_start')))
        );
  }

// Apply smoothing

var oeel=require('users/OEEL/lib:loadAll');

var order = 3;

var sgFilteredCol = oeel.ImageCollection.SavatskyGolayFilter(
  regularCol, 
  maxDiffFilter,
  distanceFunction,
  order)

print(sgFilteredCol.first(), "michu")
// print(sgFilteredCol,"sgFilteredCol")
print(sgFilteredCol.size())

// Display a time-series chart
var chart = ui.Chart.image.series({
  imageCollection: sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']),
  region: cwPlots,
  reducer: ee.Reducer.mean(),
  scale: 20
}).setOptions({
      lineWidth: 1,
      title: 'NDVI Time Series for Crested Wheatgrass',
      interpolateNulls: false,
      vAxis: {title: 'NDVI', viewWindow: {min: 0, max: 1}},
      hAxis: {title: '', format: 'YYYY-MM'},
      lineWidth: 1,
      pointSize: 4,
      series: {
        0: {color: '#66c2a4', lineDashStyle: [1, 1], pointSize: 2}, // Original NDVI
        1: {color: '#238b45', lineWidth: 2 }, // Smoothed NDVI
      },

    })
print(chart);

// Select and rename the bands you want to export
var exportCollection = sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']);

// Function to extract values for each image
var extractValues = function(image) {
  // Get the image date
  var date = ee.Date(image.get('system:time_start'));
  
  // Sample the image at each point in cwPlots
  var samples = image.sampleRegions({
    collection: allPlots,
    scale: 20, // Use the same scale as your chart
    projection: 'EPSG:4326',
    geometries: true // Keep the geometry information
  });
  
  // Add date and time information to each sample
  var samplesWithDate = samples.map(function(sample) {
    return sample.set({
      'system:time_start': image.get('system:time_start'),
      'date': date.format('YYYY-MM-dd'),
      'year': date.get('year'),
      'month': date.get('month'),
      'day': date.get('day'),
      'doy': date.getRelative('day', 'year').add(1) // Day of year
    });
  });
  
  return samplesWithDate;
};

// Map the function over all images and flatten the results
var allSamples = exportCollection.map(extractValues).flatten();

// Export the data to Google Drive
Export.table.toDrive({
  collection: allSamples,
  description: 'NDVI_5Days_2ndMethods',
  folder: 'GEE_Exports', // Change this to your preferred folder name
  fileNamePrefix: 'ndvi_timeseries_cw',
  fileFormat: 'CSV',
  selectors: [
    'system:time_start',  // Original timestamp
    'date',              // Formatted date (YYYY-MM-dd)
    'doy',               // Day of year
    'Site',              // Site name from cwPlots
    'ndvi',              // Original NDVI values
    'ndvi_sg',
    'Type'// Savitzky-Golay filtered NDVI values
  ]
});


// Method 2: Build the multi-band image manually with proper naming
var imageList = sgFilteredCol.select('d_0_ndvi').toList(sgFilteredCol.size());

var bandNames = ee.List.sequence(0, sgFilteredCol.size().subtract(1))
  .map(function(i) {
    return ee.String('t').cat(ee.Number(i).format('%02d')); // Creates: t00, t01, t02, etc.
  });

var sgFilteredBands = ee.ImageCollection.fromImages(imageList).toBands().rename(bandNames);

// Debug: Check what bands exist in sgFilteredCol
print('Available bands in sgFilteredCol:', sgFilteredBands);

Export.image.toAsset({
  image: sgFilteredBands,
  description: 'SG_Filtered_NDVI_Collection_SLPP_CreatedWithallthe2019_2020_iNaturalist',
  assetId: 'projects/usask-468318/assets/sg_filtered_ndvi_timeseries_2024',
  region: SLPP.geometry().bounds(),
  scale: 10,
  maxPixels: 1e13
});


// Create a separate FeatureCollection with band-to-date mapping
var bandDateMapping = ee.FeatureCollection(
  ee.List.sequence(0, sgFilteredCol.size().subtract(1)).map(function(i) {
    var image = ee.Image(sgFilteredCol.toList(1, i).get(0));
    var bandName = ee.String('t').cat(ee.Number(i).format('%02d'));
    
    // Convert timestamp to readable date
    var timestamp = image.get('system:time_start');
    var date = ee.Date(timestamp);
    var dateString = date.format('YYYY-MM-dd');
    var dayOfYear = date.getRelative('day', 'year').add(1);
    
    return ee.Feature(null, {
      'band_name': bandName,
      'band_index': i,
      'timestamp': timestamp,
      'date': dateString,
      'day_of_year': dayOfYear,
      'year': date.get('year'),
      'month': date.get('month'),
      'day': date.get('day')
    });
  })
);

// Export to Google Drive as CSV
Export.table.toDrive({
  collection: bandDateMapping,
  description: 'NDVI_Band_Date_Mapping_Drive',
  folder: 'GEE_Exports',
  fileNamePrefix: 'ndvi_band_dates_2024',
  fileFormat: 'CSV'
});

// Show specific properties from first mapping
var firstMapping = bandDateMapping.first();
print('First band name:', firstMapping.get('band_name'));
print('First date:', firstMapping.get('date'));
print('First day of year:', firstMapping.get('day_of_year'));

//****************************************************************************************************************//
//*****************************************5 day NDVI time series end*********************************************//
//****************************************************************************************************************//

//****************************************************************************************************************//
//*****************************************10 day NDVI time series************************************************//
//****************************************************************************************************************//

// // Select the interval. We will have 1 image every n days
// var n = 10;
// var firstImage = ee.Image(originalCollection.sort('system:time_start').first())
// var lastImage = ee.Image(originalCollection.sort('system:time_start', false).first())
// var timeStart = ee.Date(firstImage.get('system:time_start'))
// var timeEnd = ee.Date(lastImage.get('system:time_start'))

// var totalDays = timeEnd.difference(timeStart, 'day');
// var daysToInterpolate = ee.List.sequence(0, totalDays, n)

// var initImages = daysToInterpolate.map(function(day) {
//   var image = initImage.set({
//     'system:index': ee.Number(day).format('%d'),
//     'system:time_start': timeStart.advance(day, 'day').millis(),
//     // Set a property so we can identify interpolated images
//     'type': 'interpolated'
//   })
//   return image
// })


// var initCol = ee.ImageCollection.fromImages(initImages)
// print('Empty Collection', initCol.size())

// // Merge original and empty collections
// var originalCollection = originalCollection.merge(initCol)

// // Interpolation

// // Add a band containing timestamp to each image
// // This will be used to do pixel-wise interpolation later
// var originalCollection = originalCollection.map(function(image) {
//   var timeImage = image.metadata('system:time_start').rename('timestamp')
//   // The time image doesn't have a mask. 
//   // We set the mask of the time band to be the same as the first band of the image
//   var timeImageMasked = timeImage.updateMask(image.mask().select(0))
//   return image.addBands(timeImageMasked).toFloat();
// })

// // For each image in the collection, we need to find all images
// // before and after the specified time-window

// // This is accomplished using Joins
// // We need to do 2 joins
// // Join 1: Join the collection with itself to find all images before each image
// // Join 2: Join the collection with itself to find all images after each image

// // We first define the filters needed for the join

// // Define a maxDifference filter to find all images within the specified days
// // The filter needs the time difference in milliseconds
// // Convert days to milliseconds

// // Specify the time-window to look for unmasked pixel
// var days = 30;
// var millis = ee.Number(days).multiply(1000*60*60*24)

// var maxDiffFilter = ee.Filter.maxDifference({
//   difference: millis,
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // We need a lessThanOrEquals filter to find all images after a given image
// // This will compare the given image's timestamp against other images' timestamps
// var lessEqFilter = ee.Filter.lessThanOrEquals({
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // We need a greaterThanOrEquals filter to find all images before a given image
// // This will compare the given image's timestamp against other images' timestamps
// var greaterEqFilter = ee.Filter.greaterThanOrEquals({
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // Apply the joins

// // For the first join, we need to match all images that are after the given image.
// // To do this we need to match 2 conditions
// // 1. The resulting images must be within the specified time-window of target image
// // 2. The target image's timestamp must be lesser than the timestamp of resulting images
// // Combine two filters to match both these conditions
// var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// // This join will find all images after, sorted in descending order
// // This will gives us images so that closest is last
// var join1 = ee.Join.saveAll({
//   matchesKey: 'after',
//   ordering: 'system:time_start',
//   ascending: false})
  
// var join1Result = join1.apply({
//   primary: originalCollection,
//   secondary: originalCollection,
//   condition: filter1
// })
// // Each image now as a property called 'after' containing
// // all images that come after it within the time-window
// print(join1Result.first())

// // Do the second join now to match all images within the time-window
// // that come before each image
// var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// // This join will find all images before, sorted in ascending order
// // This will gives us images so that closest is last
// var join2 = ee.Join.saveAll({
//   matchesKey: 'before',
//   ordering: 'system:time_start',
//   ascending: true})
  
// var join2Result = join2.apply({
//   primary: join1Result,
//   secondary: join1Result,
//   condition: filter2
// })

// // Each image now as a property called 'before' containing
// // all images that come after it within the time-window
// print(join2Result.first())

// var joinedCol = join2Result;

// // Do the interpolation

// // We now write a function that will be used to interpolate all images
// // This function takes an image and replaces the masked pixels
// // with the interpolated value from before and after images.

// var interpolateImages = function(image) {
//   var image = ee.Image(image);
//   // We get the list of before and after images from the image property
//   // Mosaic the images so we a before and after image with the closest unmasked pixel
//   var beforeImages = ee.List(image.get('before'))
//   var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
//   var afterImages = ee.List(image.get('after'))
//   var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

//   // Interpolation formula
//   // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
//   // y = interpolated image
//   // y1 = before image
//   // y2 = after image
//   // t = interpolation timestamp
//   // t1 = before image timestamp
//   // t2 = after image timestamp
  
//   // We first compute the ratio (t – t1) / (t2 – t1)

//   // Get image with before and after times
//   var t1 = beforeMosaic.select('timestamp').rename('t1')
//   var t2 = afterMosaic.select('timestamp').rename('t2')

//   var t = image.metadata('system:time_start').rename('t')

//   var timeImage = ee.Image.cat([t1, t2, t])

//   var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
//     't': timeImage.select('t'),
//     't1': timeImage.select('t1'),
//     't2': timeImage.select('t2'),
//   })
//   // You can replace timeRatio with a constant value 0.5
//   // if you wanted a simple average
  
//   // Compute an image with the interpolated image y
//   var interpolated = beforeMosaic
//     .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
//   // Replace the masked pixels in the current image with the average value
//   var result = image.unmask(interpolated)
//   return result.copyProperties(image, ['system:time_start'])
// }

// // map() the function to interpolate all images in the collection
// var interpolatedCol = ee.ImageCollection(joinedCol.map(interpolateImages))

// // Once the interpolation are done, remove original images
// // We keep only the generated interpolated images
// var regularCol = interpolatedCol.filter(ee.Filter.eq('type', 'interpolated'))

// print(regularCol,"regularCol")

// // Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: regularCol.select('ndvi'),
//   region: cwPlots,
//   reducer: ee.Reducer.mean(),
//   scale: 20
// }).setOptions({
//       title: 'Regular NDVI Time Series',
//       interpolateNulls: false,
//       vAxis: {title: 'NDVI', viewWindow: {min: 0, max: 1}},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#238b45'},
//       },
//     })
// print(chart);

// // SavatskyGolayFilter
// // https://www.open-geocomputing.org/OpenEarthEngineLibrary/#.ImageCollection.SavatskyGolayFilter

// // Use the default distanceFunction
// var distanceFunction = function(infromedImage, estimationImage) {
//   return ee.Image.constant(
//       ee.Number(infromedImage.get('system:time_start'))
//       .subtract(
//         ee.Number(estimationImage.get('system:time_start')))
//         );
//   }

// // Apply smoothing

// var oeel=require('users/OEEL/lib:loadAll');

// var order = 3;

// var sgFilteredCol = oeel.ImageCollection.SavatskyGolayFilter(
//   regularCol, 
//   maxDiffFilter,
//   distanceFunction,
//   order)

// print(sgFilteredCol.first(), "michu")
// // print(sgFilteredCol,"sgFilteredCol")
// print(sgFilteredCol.size())

// // Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']),
//   region: cwPlots,
//   reducer: ee.Reducer.mean(),
//   scale: 20
// }).setOptions({
//       lineWidth: 1,
//       title: 'NDVI Time Series for Crested Wheatgrass',
//       interpolateNulls: false,
//       vAxis: {title: 'NDVI', viewWindow: {min: 0, max: 1}},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#66c2a4', lineDashStyle: [1, 1], pointSize: 2}, // Original NDVI
//         1: {color: '#238b45', lineWidth: 2 }, // Smoothed NDVI
//       },

//     })
// print(chart);

// // Select and rename the bands you want to export
// var exportCollection = sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']);

// // Function to extract values for each image
// var extractValues = function(image) {
//   // Get the image date
//   var date = ee.Date(image.get('system:time_start'));
  
//   // Sample the image at each point in cwPlots
//   var samples = image.sampleRegions({
//     collection: allPlots,
//     scale: 20, // Use the same scale as your chart
//     projection: 'EPSG:4326',
//     geometries: true // Keep the geometry information
//   });
  
//   // Add date and time information to each sample
//   var samplesWithDate = samples.map(function(sample) {
//     return sample.set({
//       'system:time_start': image.get('system:time_start'),
//       'date': date.format('YYYY-MM-dd'),
//       'year': date.get('year'),
//       'month': date.get('month'),
//       'day': date.get('day'),
//       'doy': date.getRelative('day', 'year').add(1) // Day of year
//     });
//   });
  
//   return samplesWithDate;
// };

// // Map the function over all images and flatten the results
// var allSamples = exportCollection.map(extractValues).flatten();

// // Export the data to Google Drive
// Export.table.toDrive({
//   collection: allSamples,
//   description: 'NDVI_10Days_2ndMethods',
//   folder: 'GEE_Exports', // Change this to your preferred folder name
//   fileNamePrefix: 'ndvi_timeseries_cw',
//   fileFormat: 'CSV',
//   selectors: [
//     'system:time_start',  // Original timestamp
//     'date',              // Formatted date (YYYY-MM-dd)
//     'doy',               // Day of year
//     'Site',              // Site name from cwPlots
//     'ndvi',              // Original NDVI values
//     'ndvi_sg',
//     'Type'// Savitzky-Golay filtered NDVI values
//   ]
// });


// // Method 2: Build the multi-band image manually with proper naming
// var imageList = sgFilteredCol.select('d_0_ndvi').toList(sgFilteredCol.size());

// var bandNames = ee.List.sequence(0, sgFilteredCol.size().subtract(1))
//   .map(function(i) {
//     return ee.String('t').cat(ee.Number(i).format('%02d')); // Creates: t00, t01, t02, etc.
//   });

// var sgFilteredBands = ee.ImageCollection.fromImages(imageList).toBands().rename(bandNames);

// // Debug: Check what bands exist in sgFilteredCol
// print('Available bands in sgFilteredCol:', sgFilteredBands);

// Export.image.toAsset({
//   image: sgFilteredBands,
//   description: 'SG_Filtered_NDVI_Collection_SLPP_CreatedWithallthe2019_2020_iNaturalist',
//   assetId: 'projects/usask-468318/assets/sg_filtered_ndvi_timeseries_2024',
//   region: SLPP.geometry().bounds(),
//   scale: 10,
//   maxPixels: 1e13
// });


// // Create a separate FeatureCollection with band-to-date mapping
// var bandDateMapping = ee.FeatureCollection(
//   ee.List.sequence(0, sgFilteredCol.size().subtract(1)).map(function(i) {
//     var image = ee.Image(sgFilteredCol.toList(1, i).get(0));
//     var bandName = ee.String('t').cat(ee.Number(i).format('%02d'));
    
//     // Convert timestamp to readable date
//     var timestamp = image.get('system:time_start');
//     var date = ee.Date(timestamp);
//     var dateString = date.format('YYYY-MM-dd');
//     var dayOfYear = date.getRelative('day', 'year').add(1);
    
//     return ee.Feature(null, {
//       'band_name': bandName,
//       'band_index': i,
//       'timestamp': timestamp,
//       'date': dateString,
//       'day_of_year': dayOfYear,
//       'year': date.get('year'),
//       'month': date.get('month'),
//       'day': date.get('day')
//     });
//   })
// );

// // Export to Google Drive as CSV
// Export.table.toDrive({
//   collection: bandDateMapping,
//   description: 'NDVI_10_Day_Band_Date_Mapping_Drive',
//   folder: 'GEE_Exports',
//   fileNamePrefix: 'NDVI_10_Day_Band_Date_Mapping_Drive',
//   fileFormat: 'CSV'
// });

//****************************************************************************************************************//
//*****************************************10 day NDVI time series end*********************************************//
//****************************************************************************************************************//


// ****************************************************************************************************************//
// *****************************************30 day NDVI time series************************************************//
// ****************************************************************************************************************//

// // Select the interval. We will have 1 image every n days
// var n = 30;
// var firstImage = ee.Image(originalCollection.sort('system:time_start').first())
// var lastImage = ee.Image(originalCollection.sort('system:time_start', false).first())
// var timeStart = ee.Date(firstImage.get('system:time_start'))
// var timeEnd = ee.Date(lastImage.get('system:time_start'))

// var totalDays = timeEnd.difference(timeStart, 'day');
// var daysToInterpolate = ee.List.sequence(0, totalDays, n)

// var initImages = daysToInterpolate.map(function(day) {
//   var image = initImage.set({
//     'system:index': ee.Number(day).format('%d'),
//     'system:time_start': timeStart.advance(day, 'day').millis(),
//     // Set a property so we can identify interpolated images
//     'type': 'interpolated'
//   })
//   return image
// })


// var initCol = ee.ImageCollection.fromImages(initImages)
// print('Empty Collection', initCol.size())

// // Merge original and empty collections
// var originalCollection = originalCollection.merge(initCol)

// // Interpolation

// // Add a band containing timestamp to each image
// // This will be used to do pixel-wise interpolation later
// var originalCollection = originalCollection.map(function(image) {
//   var timeImage = image.metadata('system:time_start').rename('timestamp')
//   // The time image doesn't have a mask. 
//   // We set the mask of the time band to be the same as the first band of the image
//   var timeImageMasked = timeImage.updateMask(image.mask().select(0))
//   return image.addBands(timeImageMasked).toFloat();
// })

// // For each image in the collection, we need to find all images
// // before and after the specified time-window

// // This is accomplished using Joins
// // We need to do 2 joins
// // Join 1: Join the collection with itself to find all images before each image
// // Join 2: Join the collection with itself to find all images after each image

// // We first define the filters needed for the join

// // Define a maxDifference filter to find all images within the specified days
// // The filter needs the time difference in milliseconds
// // Convert days to milliseconds

// // Specify the time-window to look for unmasked pixel
// var days = 120;
// var millis = ee.Number(days).multiply(1000*60*60*24)

// var maxDiffFilter = ee.Filter.maxDifference({
//   difference: millis,
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // We need a lessThanOrEquals filter to find all images after a given image
// // This will compare the given image's timestamp against other images' timestamps
// var lessEqFilter = ee.Filter.lessThanOrEquals({
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // We need a greaterThanOrEquals filter to find all images before a given image
// // This will compare the given image's timestamp against other images' timestamps
// var greaterEqFilter = ee.Filter.greaterThanOrEquals({
//   leftField: 'system:time_start',
//   rightField: 'system:time_start'
// })

// // Apply the joins

// // For the first join, we need to match all images that are after the given image.
// // To do this we need to match 2 conditions
// // 1. The resulting images must be within the specified time-window of target image
// // 2. The target image's timestamp must be lesser than the timestamp of resulting images
// // Combine two filters to match both these conditions
// var filter1 = ee.Filter.and(maxDiffFilter, lessEqFilter)
// // This join will find all images after, sorted in descending order
// // This will gives us images so that closest is last
// var join1 = ee.Join.saveAll({
//   matchesKey: 'after',
//   ordering: 'system:time_start',
//   ascending: false})
  
// var join1Result = join1.apply({
//   primary: originalCollection,
//   secondary: originalCollection,
//   condition: filter1
// })
// // Each image now as a property called 'after' containing
// // all images that come after it within the time-window
// print(join1Result.first())

// // Do the second join now to match all images within the time-window
// // that come before each image
// var filter2 = ee.Filter.and(maxDiffFilter, greaterEqFilter)
// // This join will find all images before, sorted in ascending order
// // This will gives us images so that closest is last
// var join2 = ee.Join.saveAll({
//   matchesKey: 'before',
//   ordering: 'system:time_start',
//   ascending: true})
  
// var join2Result = join2.apply({
//   primary: join1Result,
//   secondary: join1Result,
//   condition: filter2
// })

// // Each image now as a property called 'before' containing
// // all images that come after it within the time-window
// print(join2Result.first())

// var joinedCol = join2Result;

// // Do the interpolation

// // We now write a function that will be used to interpolate all images
// // This function takes an image and replaces the masked pixels
// // with the interpolated value from before and after images.

// var interpolateImages = function(image) {
//   var image = ee.Image(image);
//   // We get the list of before and after images from the image property
//   // Mosaic the images so we a before and after image with the closest unmasked pixel
//   var beforeImages = ee.List(image.get('before'))
//   var beforeMosaic = ee.ImageCollection.fromImages(beforeImages).mosaic()
//   var afterImages = ee.List(image.get('after'))
//   var afterMosaic = ee.ImageCollection.fromImages(afterImages).mosaic()

//   // Interpolation formula
//   // y = y1 + (y2-y1)*((t – t1) / (t2 – t1))
//   // y = interpolated image
//   // y1 = before image
//   // y2 = after image
//   // t = interpolation timestamp
//   // t1 = before image timestamp
//   // t2 = after image timestamp
  
//   // We first compute the ratio (t – t1) / (t2 – t1)

//   // Get image with before and after times
//   var t1 = beforeMosaic.select('timestamp').rename('t1')
//   var t2 = afterMosaic.select('timestamp').rename('t2')

//   var t = image.metadata('system:time_start').rename('t')

//   var timeImage = ee.Image.cat([t1, t2, t])

//   var timeRatio = timeImage.expression('(t - t1) / (t2 - t1)', {
//     't': timeImage.select('t'),
//     't1': timeImage.select('t1'),
//     't2': timeImage.select('t2'),
//   })
//   // You can replace timeRatio with a constant value 0.5
//   // if you wanted a simple average
  
//   // Compute an image with the interpolated image y
//   var interpolated = beforeMosaic
//     .add((afterMosaic.subtract(beforeMosaic).multiply(timeRatio)))
//   // Replace the masked pixels in the current image with the average value
//   var result = image.unmask(interpolated)
//   return result.copyProperties(image, ['system:time_start'])
// }

// // map() the function to interpolate all images in the collection
// var interpolatedCol = ee.ImageCollection(joinedCol.map(interpolateImages))

// // Once the interpolation are done, remove original images
// // We keep only the generated interpolated images
// var regularCol = interpolatedCol.filter(ee.Filter.eq('type', 'interpolated'))

// print(regularCol,"regularCol")

// // Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: regularCol.select('ndvi'),
//   region: cwPlots,
//   reducer: ee.Reducer.mean(),
//   scale: 20
// }).setOptions({
//       title: 'Regular NDVI Time Series',
//       interpolateNulls: false,
//       vAxis: {title: 'NDVI', viewWindow: {min: 0, max: 1}},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#238b45'},
//       },
//     })
// print(chart);

// // SavatskyGolayFilter
// // https://www.open-geocomputing.org/OpenEarthEngineLibrary/#.ImageCollection.SavatskyGolayFilter

// // Use the default distanceFunction
// var distanceFunction = function(infromedImage, estimationImage) {
//   return ee.Image.constant(
//       ee.Number(infromedImage.get('system:time_start'))
//       .subtract(
//         ee.Number(estimationImage.get('system:time_start')))
//         );
//   }

// // Apply smoothing

// var oeel=require('users/OEEL/lib:loadAll');

// var order = 3;

// var sgFilteredCol = oeel.ImageCollection.SavatskyGolayFilter(
//   regularCol, 
//   maxDiffFilter,
//   distanceFunction,
//   order)

// print(sgFilteredCol.first(), "michu")
// // print(sgFilteredCol,"sgFilteredCol")
// print(sgFilteredCol.size())

// // Display a time-series chart
// var chart = ui.Chart.image.series({
//   imageCollection: sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']),
//   region: cwPlots,
//   reducer: ee.Reducer.mean(),
//   scale: 20
// }).setOptions({
//       lineWidth: 1,
//       title: 'NDVI Time Series for Crested Wheatgrass',
//       interpolateNulls: false,
//       vAxis: {title: 'NDVI', viewWindow: {min: 0, max: 1}},
//       hAxis: {title: '', format: 'YYYY-MM'},
//       lineWidth: 1,
//       pointSize: 4,
//       series: {
//         0: {color: '#66c2a4', lineDashStyle: [1, 1], pointSize: 2}, // Original NDVI
//         1: {color: '#238b45', lineWidth: 2 }, // Smoothed NDVI
//       },

//     })
// print(chart);

// // Select and rename the bands you want to export
// var exportCollection = sgFilteredCol.select(['ndvi', 'd_0_ndvi'], ['ndvi', 'ndvi_sg']);

// // Function to extract values for each image
// var extractValues = function(image) {
//   // Get the image date
//   var date = ee.Date(image.get('system:time_start'));
  
//   // Sample the image at each point in cwPlots
//   var samples = image.sampleRegions({
//     collection: allPlots,
//     scale: 20, // Use the same scale as your chart
//     projection: 'EPSG:4326',
//     geometries: true // Keep the geometry information
//   });
  
//   // Add date and time information to each sample
//   var samplesWithDate = samples.map(function(sample) {
//     return sample.set({
//       'system:time_start': image.get('system:time_start'),
//       'date': date.format('YYYY-MM-dd'),
//       'year': date.get('year'),
//       'month': date.get('month'),
//       'day': date.get('day'),
//       'doy': date.getRelative('day', 'year').add(1) // Day of year
//     });
//   });
  
//   return samplesWithDate;
// };

// // Map the function over all images and flatten the results
// var allSamples = exportCollection.map(extractValues).flatten();

// // Export the data to Google Drive
// Export.table.toDrive({
//   collection: allSamples,
//   description: 'NDVI_30Days_2ndMethods',
//   folder: 'GEE_Exports', // Change this to your preferred folder name
//   fileNamePrefix: 'ndvi_timeseries_cw',
//   fileFormat: 'CSV',
//   selectors: [
//     'system:time_start',  // Original timestamp
//     'date',              // Formatted date (YYYY-MM-dd)
//     'doy',               // Day of year
//     'Site',              // Site name from cwPlots
//     'ndvi',              // Original NDVI values
//     'ndvi_sg',
//     'Type'// Savitzky-Golay filtered NDVI values
//   ]
// });


// // Method 2: Build the multi-band image manually with proper naming
// var imageList = sgFilteredCol.select('d_0_ndvi').toList(sgFilteredCol.size());

// var bandNames = ee.List.sequence(0, sgFilteredCol.size().subtract(1))
//   .map(function(i) {
//     return ee.String('t').cat(ee.Number(i).format('%02d')); // Creates: t00, t01, t02, etc.
//   });

// var sgFilteredBands = ee.ImageCollection.fromImages(imageList).toBands().rename(bandNames);

// // Debug: Check what bands exist in sgFilteredCol
// print('Available bands in sgFilteredCol:', sgFilteredBands);

// Export.image.toAsset({
//   image: sgFilteredBands,
//   description: 'SG_Filtered_NDVI_Collection_SLPP_CreatedWithallthe2019_2020_iNaturalist',
//   assetId: 'projects/usask-468318/assets/sg_filtered_ndvi_timeseries_2024',
//   region: SLPP.geometry().bounds(),
//   scale: 10,
//   maxPixels: 1e13
// });


// // Create a separate FeatureCollection with band-to-date mapping
// var bandDateMapping = ee.FeatureCollection(
//   ee.List.sequence(0, sgFilteredCol.size().subtract(1)).map(function(i) {
//     var image = ee.Image(sgFilteredCol.toList(1, i).get(0));
//     var bandName = ee.String('t').cat(ee.Number(i).format('%02d'));
    
//     // Convert timestamp to readable date
//     var timestamp = image.get('system:time_start');
//     var date = ee.Date(timestamp);
//     var dateString = date.format('YYYY-MM-dd');
//     var dayOfYear = date.getRelative('day', 'year').add(1);
    
//     return ee.Feature(null, {
//       'band_name': bandName,
//       'band_index': i,
//       'timestamp': timestamp,
//       'date': dateString,
//       'day_of_year': dayOfYear,
//       'year': date.get('year'),
//       'month': date.get('month'),
//       'day': date.get('day')
//     });
//   })
// );

// // Export to Google Drive as CSV
// Export.table.toDrive({
//   collection: bandDateMapping,
//   description: 'NDVI_30_Day_Band_Date_Mapping_Drive',
//   folder: 'GEE_Exports',
//   fileNamePrefix: 'NDVI_30_Day_Band_Date_Mapping_Drive',
//   fileFormat: 'CSV'
// });

// ****************************************************************************************************************//
// *****************************************30 day NDVI time series end*********************************************//
// ****************************************************************************************************************//

